<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AIS Live Map</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  >
  <style>
    :root {
      color-scheme: dark;
      font-family: Arial, Helvetica, sans-serif;
    }
    body {
      margin: 0;
      background: #0f172a;
      color: #e2e8f0;
    }
    .topbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid #1e293b;
      background: #111827;
      flex-wrap: wrap;
    }
    h1 {
      margin: 0;
      font-size: 1.2rem;
    }
    .meta {
      margin: 0;
      color: #94a3b8;
      font-size: 0.92rem;
    }
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 600;
      background: #7f1d1d;
      color: #fee2e2;
    }
    .status.connected {
      background: #14532d;
      color: #dcfce7;
    }
    .status.disconnected {
      background: #7f1d1d;
      color: #fee2e2;
    }
    .spacer {
      flex: 1;
    }
    .link {
      color: #93c5fd;
      text-decoration: none;
      font-weight: 600;
    }
    .link:hover {
      text-decoration: underline;
    }
    #map {
      width: 100%;
      height: calc(100vh - 62px);
    }
    .leaflet-popup-content {
      margin: 10px 12px;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <h1>AIS Live Map</h1>
    <p class="meta">
      Streaming from <code>/api/v1/live</code>
      <span id="conn-status" class="status disconnected">Disconnected</span>
      <span id="vessel-count">0 vessels tracked</span>
    </p>
    <div class="spacer"></div>
    <a class="link" href="/">Table View</a>
  </div>
  <div id="map" aria-label="Live vessel map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script>
    const markerByMmsi = new Map();
    const vesselCountEl = document.getElementById("vessel-count");
    const statusEl = document.getElementById("conn-status");

    let zoneBbox = null;
    let bboxLayer = null;
    const inZone = (lat, lon) => {
      if (zoneBbox == null) return true;
      return Number.isFinite(lat) && Number.isFinite(lon) &&
        lat >= zoneBbox.lat_min && lat <= zoneBbox.lat_max &&
        lon >= zoneBbox.lon_min && lon <= zoneBbox.lon_max;
    };

    const map = L.map("map", {
      zoomControl: true,
      minZoom: 2
    }).setView([44.65, -63.58], 11);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    const drawBboxLayer = (b) => {
      if (bboxLayer) {
        map.removeLayer(bboxLayer);
        bboxLayer = null;
      }
      if (!Number.isFinite(b.lat_min + b.lat_max + b.lon_min + b.lon_max)) return;
      const southWest = [b.lat_min, b.lon_min];
      const northEast = [b.lat_max, b.lon_max];
      bboxLayer = L.rectangle([southWest, northEast], {
        color: "#38bdf8",
        weight: 2,
        fillColor: "#0ea5e9",
        fillOpacity: 0.08,
        dashArray: "6, 4"
      });
      bboxLayer.addTo(map);
    };

    fetch("/api/v1/stats")
      .then((r) => r.ok ? r.json() : null)
      .then((stats) => {
        if (stats && stats.bbox) {
          zoneBbox = stats.bbox;
          const b = stats.bbox;
          if (Number.isFinite(b.lat_min + b.lat_max + b.lon_min + b.lon_max)) {
            map.fitBounds([[b.lat_min, b.lon_min], [b.lat_max, b.lon_max]], { padding: [20, 20], maxZoom: 14 });
            drawBboxLayer(b);
          }
        }
      })
      .catch(() => {});

    const setConnected = (connected) => {
      statusEl.textContent = connected ? "Connected" : "Disconnected";
      statusEl.classList.toggle("connected", connected);
      statusEl.classList.toggle("disconnected", !connected);
    };

    const validCoord = (lat, lon) => {
      return Number.isFinite(lat) &&
        Number.isFinite(lon) &&
        lat >= -90 &&
        lat <= 90 &&
        lon >= -180 &&
        lon <= 180;
    };

    const popupHtml = (data) => {
      const speed = Number.isFinite(Number(data.speed)) ? Number(data.speed).toFixed(2) : "-";
      const course = Number.isFinite(Number(data.course)) ? Number(data.course).toFixed(2) : "-";
      const heading = data.heading ?? "-";
      const when = data.time ? new Date(data.time).toISOString() : "-";
      return `
        <strong>MMSI:</strong> ${data.mmsi ?? "-"}<br>
        <strong>Speed:</strong> ${speed} kn<br>
        <strong>Course:</strong> ${course}Â°<br>
        <strong>Heading:</strong> ${heading}<br>
        <strong>Time:</strong> ${when}
      `;
    };

    const updateMarker = (data) => {
      const key = String(data.mmsi);
      const lat = Number(data.latitude);
      const lon = Number(data.longitude);
      if (!data.mmsi || !validCoord(lat, lon)) {
        return;
      }
      if (!inZone(lat, lon)) {
        const existing = markerByMmsi.get(key);
        if (existing) {
          map.removeLayer(existing);
          markerByMmsi.delete(key);
          vesselCountEl.textContent = `${markerByMmsi.size} vessels tracked`;
        }
        return;
      }

      const existing = markerByMmsi.get(key);
      if (existing) {
        existing.setLatLng([lat, lon]);
        existing.setPopupContent(popupHtml(data));
      } else {
        const marker = L.circleMarker([lat, lon], {
          radius: 5,
          color: "#38bdf8",
          fillColor: "#0ea5e9",
          fillOpacity: 0.9,
          weight: 1
        });
        marker.bindPopup(popupHtml(data));
        marker.addTo(map);
        markerByMmsi.set(key, marker);
        if (markerByMmsi.size === 1 && zoneBbox == null) {
          map.setView([lat, lon], 7);
        }
      }

      vesselCountEl.textContent = `${markerByMmsi.size} vessels tracked`;
    };

    const es = new EventSource("/api/v1/live");
    es.onopen = () => setConnected(true);
    es.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        updateMarker(data);
      } catch (_) {
        // Ignore malformed events.
      }
    };
    es.onerror = () => setConnected(false);
  </script>
</body>
</html>
